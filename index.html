<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>存在主义是一种人道主义</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1.13.0.css">


    <script>
        window.isPost = false
        window.aomori = {
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false
    </script>

<meta name="generator" content="Hexo 5.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="Haoyu-Cai">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>存在主义是一种人道主义</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
  id="post-GEAch3"
  class="article article-type-post"
>

  

  <div class="article-inner">
    

    <div class="article-body">
      <header class="article-title">
        <a href="/2021/01/03/GEAch3/">GEAch3</a>
      </header>
      <div class="article-entry post-inner-html">
        
          <h3 id="游戏软件工程基础"><a href="#游戏软件工程基础" class="headerlink" title="游戏软件工程基础"></a>游戏软件工程基础</h3><h4 id="3-2-c-c-的数据、代码及内存"><a href="#3-2-c-c-的数据、代码及内存" class="headerlink" title="3.2 c/c++的数据、代码及内存"></a>3.2 c/c++的数据、代码及内存</h4><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>最流行的定义浮点数标准是IEEE-754,其最高有效位是符号位，紧随其后的是8位指数和23位尾数。</p>
<p>IEEE 32位浮点数可表示的最大值为3.403*10^38；可表示的最小非0值为1.175*10^-38。epsilon为1.192*10^-7（epsiison 表示1+e=1的最大值）。</p>
<p>有限精度和机器epsilon的概念，在程序设计的过程中非常有用，将该要素纳入考虑能够避免很多预期外的情况发生。</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>可执行和可链接格式（executable and linkable format, ELF）是链接器创建的一种可执行文件格式。在UNIX平台上使用.elf扩展名，在Windows平台上使用.exe扩展名。</p>
<p>可执行映像，一般最少由以下几个段组成</p>
<ul>
<li>代码段：包含程序中定义的全部函数的可执行机器码。</li>
<li>数据段：包含全部<strong>获初始化</strong>的全局及静态变量，链接器会填入适当的初始值。</li>
<li>BSS段：包含全部<strong>未初始化</strong>的全局及静态变量。根据C/C++的定义，任何未初始化的全局变量和静态变量均为0。链接器只简单地存储所需零值的个数在可执行映像中。当操作系统载入程序时，会保留BSS所需的字节个数。并为该部分内存填入0。</li>
<li>只读数据段：又称<code>rodata</code>段，包含所有浮点常量及所有用<code>const</code>声明的全局对象实例。</li>
</ul>
<h3 id="程序堆栈"><a href="#程序堆栈" class="headerlink" title="程序堆栈"></a>程序堆栈</h3><p>略</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><h4 id="对齐和包裹"><a href="#对齐和包裹" class="headerlink" title="对齐和包裹"></a>对齐和包裹</h4><p>数据对象的对齐是指，其内存地址是否为对齐字节大小的倍数（通常是2的幂）。对齐是重要的。因为现在许多处理器实际上只能正常地读/写已对齐的数据块。</p>
<p>作为一个良好的经验法则，数据类型应该需要其字节大小的对齐。包含4个浮点数的SIMD矢量通常需要16字节对齐。</p>
<p>整个结构的对齐需求等于其成员中的最大对齐需求。</p>
<h3 id="C-中类的布局"><a href="#C-中类的布局" class="headerlink" title="C++中类的布局"></a>C++中类的布局</h3><p>C++中的类有别于C的结构有二</p>

        
      </div>
    </div>

    

  </div>

  <footer class="article-footer">
    <div class="article-more-info">
      <div class="article-date">
  <time datetime="2021-01-03T02:03:46.000Z" itemprop="datePublished">2021-01-03</time>
</div>
      
      
        <div class="article-tag">
          <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAME-design/" rel="tag">GAME design</a></li></ul>
        </div>
      
    </div>
  </footer>

</article>

    
  
    
      <article
  id="post-diannao"
  class="article article-type-post"
>

  

  <div class="article-inner">
    

    <div class="article-body">
      <header class="article-title">
        <a href="/2021/01/02/diannao/">DIANNAO论文导读</a>
      </header>
      <div class="article-entry post-inner-html">
        
          <h2 id="DIANNAO论文导读"><a href="#DIANNAO论文导读" class="headerlink" title="DIANNAO论文导读"></a>DIANNAO论文导读</h2><p>DIANNAO系列论文是寒武纪人工智能加速芯片的理论依据。<br>对于研究人工智能硬件加速领域的学者而言，DIANNAO系列论文是不可不读的经典之作。</p>
<h3 id="DIANNAO的前世今生"><a href="#DIANNAO的前世今生" class="headerlink" title="DIANNAO的前世今生"></a>DIANNAO的前世今生</h3><p><img src="https://wx1.sinaimg.cn/large/006W6gr8ly1g9n98m3u9jj30zh0h5wg3.jpg" alt="img"><br>本文是对 <code>DianNao: A Small-Footprint High-Throughput Accelerator for Ubiquitous Machine-Learning</code> 的内容做一个简介</p>
<h3 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h3><p>作者认为截止到2014年为止体系结构领域存在三大趋势：</p>
<ul>
<li>异构多核架构成为主流<ul>
<li>需要高效灵活的加速器</li>
</ul>
</li>
<li>许多新的高性能及嵌入式应用和所有的人工智能应用都依赖于机器学习<ul>
<li>需要优化机器学习的性能</li>
</ul>
</li>
<li>基于神经网络（尤其是CNN和DNN）的有限几种技术在许多应用场景中都是最有效且最先进的。<ul>
<li>对CNN和DNN等少数几种算法进行优化</li>
</ul>
</li>
</ul>
<p>于是得出结论：设计一种专门加速CNN和DNN的加速器的需求非常合理且迫切。</p>
<p>那么他们是否成功了呢？<br>事实证明他们成功了，并提出了一种65nm的设计，该设计可以在每3.02mm2的空间、485mW的功耗（不包括主存储器访问）每1.02ns并行执行496个16位定点运算，即452 GOP / s。在CNN和DNN中建立的10层最大网络中，该加速器比时钟频率为2GHz的128位SIMD内核平均快117.87倍，能源效率（包括主存储器访问）平均提高21.08倍。<br><img src="https://wx3.sinaimg.cn/large/006W6gr8ly1g9n9ldl6ejj30eb0byts1.jpg" alt="img"></p>
<blockquote>
<p>以上为该芯片的布局图</p>
</blockquote>
<p>于是问题来了, 怎样的设计能达到这样的性能我们先介绍一下一些必须知道的CNN性质再回答这个问题</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="Processing-vs-training"><a href="#Processing-vs-training" class="headerlink" title="Processing vs. training."></a>Processing vs. training.</h4><p>在工业界，离线训练往往比在线训练更有效且更常见。所以本文作者专注于前馈网络进行加速。（注意反向传播性质与前馈网络的计算与内存访问模式相似。所以在未来的研究中有可能支持训练）</p>
<h4 id="General-structure"><a href="#General-structure" class="headerlink" title="General structure."></a>General structure.</h4><p>卷积神经网络的一般结构如下：<br><img src="https://wx1.sinaimg.cn/large/006W6gr8ly1g9n9r31h0ij30kj0b8dja.jpg" alt="img"><br>卷积、池化、分类是卷积神经网络中的一般操作。我们分别讲解一下它们的特征</p>
<h4 id="Convolutional-layers"><a href="#Convolutional-layers" class="headerlink" title="Convolutional layers."></a>Convolutional layers.</h4><p>一个简单的卷积映射如下图所示。<br><img src="https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202815705-1130979104.gif" alt="img"><br>更一般的卷积映射如下<br><img src="http://xukeqiniu.xukeai.cn/%E5%8D%B7%E7%A7%AF%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%A4%BA.gif" alt="img"><br>存在多个输入特征图和输出特征图。图中动态显示了计算其中一层输出特征图的状态。每一层输出特征图的计算逻辑都是相同的，但不同层的计算使用的kernel或者说filter是不同的；图中左边的kernel是另一个输出图层所使用的。<br>这里强调一下 private kernel 和 shared kernel的 区别：<br><strong>每个时间步在动图上计算一个结果，privete kernel 就意味着每个时间步使用的 kernel 都不一样</strong><br>文章中给出了一个卷积层运算的示意图，这里把输入特征图叠到一起，把输出特征图叠到一起。图中表示进行单个上图中的映射计算。<br><img src="https://wx2.sinaimg.cn/large/006W6gr8ly1g9nae215nej30f408vta1.jpg" alt="img"></p>
<h4 id="Pooling-layers"><a href="#Pooling-layers" class="headerlink" title="Pooling layers."></a>Pooling layers.</h4><p>　　为了有效地减少计算量，CNN使用的另一个有效的工具被称为“池化(Pooling)”。池化就是将输入图像进行缩小，减少像素信息，只保留重要信息。<br>　　池化的操作也很简单，通常情况下，池化区域是2<em>2大小，然后按一定规则转换成相应的值，例如取这个池化区域内的最大值（max-pooling）、平均值（mean-pooling）等，以这个值作为结果的像素值。<br>　　下图显示了左上角2</em>2池化区域的max-pooling结果，取该区域的最大值max(0.77,-0.11,-0.11,1.00)，作为池化后的结果，如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0210/003312_A4YP_876354.png" alt="img"><br>　　池化区域往左，第二小块取大值max(0.11,0.33,-0.11,0.33)，作为池化后的结果，如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0210/003318_39Ru_876354.png" alt="img"><br>　　其它区域也是类似，取区域内的最大值作为池化后的结果，最后经过池化后，结果如下：<br><img src="https://static.oschina.net/uploads/space/2018/0210/003323_Jy2u_876354.png" alt="img"><br>　　对所有的feature map执行同样的操作，结果如下：<br><img src="https://static.oschina.net/uploads/space/2018/0210/003329_XCiq_876354.png" alt="img"><br>　　最大池化（max-pooling）保留了每一小块内的最大值，也就是相当于保留了这一块最佳的匹配结果（因为值越接近1表示匹配越好）。也就是说，它不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了。<br>　　通过加入池化层，图像缩小了，能很大程度上减少计算量，降低机器负载。</p>
<p>更一般的池化如左图所示，其实就是独立的对每一个特征图进行池化。运算上比卷积层更加简单。</p>
<p><img src="https://wx4.sinaimg.cn/large/006W6gr8ly1g9naqg34r3j30fy0a6abk.jpg" alt="img"></p>
<h4 id="Classifier-Layers"><a href="#Classifier-Layers" class="headerlink" title="Classifier Layers."></a>Classifier Layers.</h4><p>在分类之前，先对特征图进行平展化（也就是把图展开成一维数据）</p>
<p>　　全连接层在整个卷积神经网络中起到“分类器”的作用，即通过卷积、激活函数、池化等深度网络后，再经过全连接层对结果进行识别分类。<br>　　首先将经过卷积、激活函数、池化的深度网络后的结果串起来，如下图所示：**<br><img src="https://static.oschina.net/uploads/space/2018/0210/003434_MygV_876354.png" alt="img"><br>**　　由于神经网络是属于监督学习，在模型训练时，根据训练样本对模型进行训练，从而得到全连接层的权重（如预测字母X的所有连接的权重）**<br> <img src="https://static.oschina.net/uploads/space/2018/0210/003440_MLD0_876354.png" alt="img"><br>**　　在利用该模型进行结果识别时，根据刚才提到的模型训练得出来的权重，以及经过前面的卷积、激活函数、池化等深度网络计算出来的结果，进行加权求和，得到各个结果的预测值，然后取值最大的作为识别的结果（如下图，最后计算出来字母X的识别值为0.92，字母O的识别值为0.51，则结果判定为X）**<br> <img src="https://static.oschina.net/uploads/space/2018/0210/003445_oQwf_876354.png" alt="img"><br>**　　上述这个过程定义的操作为”全连接层“(Fully connected layers)，全连接层也可以有多个，如下图：**<br> <img src="https://static.oschina.net/uploads/space/2018/0210/003451_GX0E_876354.png" alt="img">**</p>
<p>更一般的全连接图文章中如下：<br><img src="https://wx1.sinaimg.cn/large/006W6gr8ly1g9naqv0nmfj30ay09zq3l.jpg" alt="img"></p>
<h4 id="为什么不直接用硬件去实现大规模神经网络？"><a href="#为什么不直接用硬件去实现大规模神经网络？" class="headerlink" title="为什么不直接用硬件去实现大规模神经网络？"></a>为什么不直接用硬件去实现大规模神经网络？</h4><p>就运算符而言，它对应于两个16x1 16位多路复用器（用于段边界选择，即xi，xi + 1），一个16位乘法器（16位输出）和一个16位加法器执行插值。<br>16段系数（ai; bi）存储在一个小RAM中； 这仅通过改变RAM段系数ai就可以实现任何功能，而不仅是S形（例如，双曲正切，线性函数等）； 双段边界（xi; xi + 1）是硬连线的。<br><img src="https://wx4.sinaimg.cn/large/006W6gr8ly1g9narr7j9zj30k60ewdj4.jpg" alt="img"></p>
<p>但是，面积，能量和延迟随着神经元数量的增加而平方增长。<br>考虑到大规模神经网络中的神经元数以千计，仅一层的完整硬件布局范围就可能在数百或数千mm2之间，因此，这种方法对于大规模神经网络是不现实的。<br>想要保证加速器计算密度较高，最多一部分神经元和突触可以在硬件中实现<br>因此加速器件需要在内存层次和计算层次架构得更加合理</p>
<h4 id="Large-scale-Neural-Networks（图为深度卷积网络VGGNET）"><a href="#Large-scale-Neural-Networks（图为深度卷积网络VGGNET）" class="headerlink" title="Large-scale Neural Networks（图为深度卷积网络VGGNET）"></a>Large-scale Neural Networks（图为深度卷积网络VGGNET）</h4><p><img src="https://wx4.sinaimg.cn/large/006W6gr8ly1g9nas8b3zmj30z90k3qav.jpg" alt="img"><br>现在的神经网络规模都是非常大的。运算数据不可能完全装进L1 Cache！(甚至L2 Cache)<br>数据换入换出将导致巨大开销。而计算上的优化前人已经做的非常好了，根据Amdahl定律减少内存传输的代价才能最大程度优化该算法。</p>
<h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><p>假设：<br>使用了含缓存的加速器。<br>缓存层次结构受Intel Core i7启发：<br>L1为32KB，每行64字节，8路；<br>L2为2MB，每行64字节，8路。<br>与Core i7不同，我们假设高速缓存具有足够的存储体/端口来为neuron数组提供Tn×4字节，为synapse数组提供Tn×Ti×4字节。能将Ti<em>Tn的二层循环内的数据的Ti</em>Tn次串行计算并行化。<br>e.g.<img src="https://wx3.sinaimg.cn/mw690/006W6gr8ly1g9nasfuq62j309i01yq37.jpg" alt="img"><br>对于太大的Tn和Ti值。此类缓存的成本可能令人望而却步<br>在我们的实验中，我们使用Tn = Ti = 16。</p>
<p>作者分别用tiled算法优化了算法的三个不同部分。优化结果如下：<br><img src="https://wx2.sinaimg.cn/large/006W6gr8ly1g9nat3c4efj30ka0ezwhb.jpg" alt="img"><br><img src="https://wx3.sinaimg.cn/large/006W6gr8ly1g9nat6gdjsj30m10h4jx7.jpg" alt="img"><br>以上是benchmark规模</p>
<h3 id="加速器架构"><a href="#加速器架构" class="headerlink" title="加速器架构"></a>加速器架构</h3><p><img src="https://wx1.sinaimg.cn/large/006W6gr8ly1g9natdemlrj30kl0hn0wx.jpg" alt="img"><br>加速器由NFU/stroage/CP三部分组成</p>
<h4 id="NFU"><a href="#NFU" class="headerlink" title="NFU"></a>NFU</h4><p>NFU有一下三个特性<br>· Staggered pipeline<br>通过流水线提升运行效率<br>· NFU-3 function implementation<br>前文中已表示了神经网络中激励函数的实现方式，下文不在赘述<br>· 16-bit fixed-point arithmetic operators<br>使用16位定点运算部件</p>
<h4 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h4><p>Q：为什么切分buffer？使用单个多端口buffer似乎更加方便？<br>A：Concerning Width &amp; Conflicts<br>拆分结构的第一个好处是将SRAM调整为适当的读/写宽度。<br>NBin和NBout的宽度均为Tn×2字节，而SB的宽度为Tn×Tn×2字节。<br>单个读取宽度大小（例如，与高速缓存行大小相同）将是较差的权衡。<br>如果将其调整为突触，即，如果行大小为Tn×Tn×2，则从Tn×Tn×2宽数据库中读取Tn×2个字节会产生巨大的能量损失，请参见图13，该图表明 对于65nm的TSMC工艺，SRAM读取的能量是存储区宽度的函数。<br>如果将行大小调整为适合神经元，即，如果行大小为Tn×2，则读取Tn×Tn×2个字节会耗费大量时间。<br>将存储分为专用结构可以为每个读取请求获得最佳时间和精力。<br>冲突。<br>拆分存储结构的第二个好处是避免发生冲突，就像在高速缓存中那样。<br>由于我们出于成本和能源（泄漏）的原因要使存储结构的尺寸保持较小，这一点尤其重要。<br>替代解决方案是使用高度关联的缓存。<br>请考虑以下约束条件：高速缓存行（或端口数量）需要很大（Tn×Tn×2），才能以较高的速率服务于突触； 因为我们希望保持高速缓存的大小很小，所以忍受这么长的高速缓存行的唯一选择是高关联性。<br>但是，在n路高速缓存中，通过推测性地并行读取所有n路/存储库来实现快速读取。<br>结果，关联缓存的能量成本迅速增加。<br>即使是从8路关联的32KB高速缓存中读取64字节，其能耗也比从直接映射的高速缓存中32字节读取65nm的能耗高3.15倍。<br>使用CACTI进行的测量[40]。<br>即使仅使用64字节的行，Core i7的第一级32KB数据高速缓存已经是8路关联的，因此我们需要具有很大行的更大关联性（对于Tn = 16，行大小为 512字节长）。<br>换句话说，在我们的案例中，高度关联的缓存将是昂贵的能源解决方案。<br>分离存储和对位置行为的精确了解可以完全消除数据冲突。</p>
<h5 id="Exploiting-the-locality-of-inputs-and-synapses"><a href="#Exploiting-the-locality-of-inputs-and-synapses" class="headerlink" title="Exploiting the locality of inputs and synapses"></a>Exploiting the locality of inputs and synapses</h5><ul>
<li><p>DMAs</p>
</li>
<li><p>Rotating NBin buffer for temporal reuse of input neurons（pooling和conv存在overlap）</p>
</li>
<li><p>Local transpose in NBin for pooling layers</p>
<p>DMA。</p>
<p>对于空间局部性开发，我们实现了三个DMA，每个缓冲区一个（两个负载DMA，一个用于输出的存储DMA）。</p>
<p>DMA请求以指令形式发送给NBin，稍后在第5.3.2节中进行描述。</p>
<p>这些请求被缓冲在与每个缓冲区关联的单独的FIFO中（参见图11），并且在DMA发送了前一条指令的所有存储请求后立即发出这些请求。</p>
<p>这些DMA请求FIFO可以将发出给所有缓冲区和NFU的请求与当前缓冲区和NFU操作解耦。</p>
<p>因此，只要有足够的缓冲区容量，就可以提前预装DMA请求以容忍较长的等待时间。</p>
<p>这种预加载类似于预取，尽管没有推测。</p>
<p>由于NBin（和SB）同时用作重用和预加载缓冲器的暂存器，因此我们使用了双端口SRAM。</p>
<p>台积电（TSMC）65nm库将64项NB的双端口SRAM的读取能量开销估计为24％。</p>
<p>旋转NBin缓冲区，可暂时重用输入神经元。</p>
<p>所有层的输入都分成适合NBin的块，并通过将NBin实现为循环缓冲区来重用它们。</p>
<p>实际上，轮换自然是通过更改寄存器索引来实现的，就像在软件实现中一样，缓冲区条目没有物理（且昂贵）的移动。</p>
<p>NBin中的本地转置用于池化层。</p>
<p>卷积层和池化层之间对于（输入）神经元的数据结构组织存在紧张关系。</p>
<p>如前所述，Kx； Ky通常很小（通常小于10），Ni大约大一个数量级。</p>
<p>因此，将输入要素映射作为三维神经元数据结构的最内层索引，内存提取会更有效（长步1访问）。</p>
<p>然而，这对于合并层是不方便的，因为每个输入特征图仅计算一个输出，即仅使用Kx×Ky数据（而在卷积层中，需要所有Kx×Ky×Ni数据来计算一个输出数据）。</p>
<p>结果，对于池层，逻辑数据结构组织将具有kx； ky作为最里面的尺寸，以便将计算一个输出所需的所有输入连续存储在NBin缓冲区中。</p>
<p>我们通过在NBin中引入映射函数来解决此问题，该函数具有局部转置循环ky的作用； kx和循环i，以便沿循环i加载数据，但将其存储在NBin中，然后沿循环ky发送到NFU； kx首先； 这是通过在加载数据时将数据插入NBin来实现的，请参见图14。</p>
<p>如第3节所述，对于突触和SB，没有重用（分类器层，具有专用内核和池化层的卷积层），也没有在卷积层中重用共享内核。</p>
<p>对于输出和NBout，我们需要重用部分和，即 ，参见图5中的参考sum [n]。这种重用需要在下一节中说明的其他硬件修改。</p>
</li>
</ul>
<h5 id="Exploiting-the-locality-of-outputs"><a href="#Exploiting-the-locality-of-outputs" class="headerlink" title="Exploiting the locality of outputs."></a>Exploiting the locality of outputs.</h5><ul>
<li><p>Dedicated registers</p>
</li>
<li><p>Circular buffer （reuse NBout） 绝妙的观察！</p>
<table>
<thead>
<tr>
<th>是否活跃</th>
<th>NFU-1</th>
<th>NFU-2</th>
<th>NFU-3</th>
</tr>
</thead>
<tbody><tr>
<td>POOL</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>CONV</td>
<td>√</td>
<td>√</td>
<td>if 写入Nbout then 活跃 /if 不写入 Nbout 不活跃</td>
</tr>
<tr>
<td>CLASS</td>
<td>√</td>
<td>√</td>
<td>if 写入Nbout then 活跃 /if 不写入 Nbout 不活跃</td>
</tr>
</tbody></table>
</li>
</ul>

        
      </div>
    </div>

    

  </div>

  <footer class="article-footer">
    <div class="article-more-info">
      <div class="article-date">
  <time datetime="2021-01-02T12:33:17.000Z" itemprop="datePublished">2021-01-02</time>
</div>
      
        <div class="article-category">
          <a class="article-category-link" href="/categories/papers/">papers</a>
        </div>
      
      
        <div class="article-tag">
          <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fpga-accelator/" rel="tag">fpga accelator</a></li></ul>
        </div>
      
    </div>
  </footer>

</article>

    
  
    
      <article
  id="post-git"
  class="article article-type-post"
>

  

  <div class="article-inner">
    

    <div class="article-body">
      <header class="article-title">
        <a href="/2021/01/02/git/">GIT 入门</a>
      </header>
      <div class="article-entry post-inner-html">
        
          <h3 id="GIT-入门"><a href="#GIT-入门" class="headerlink" title="GIT 入门"></a>GIT 入门</h3><p><code>git</code> 是目前最常用的分布式版本控制系统,由 linus 开发。<br>包括<code>GitHub</code>在内的许多代码托管网站均使用<code>git</code>作为版本控制器。</p>
<h4 id="1-简单的GIT命令"><a href="#1-简单的GIT命令" class="headerlink" title="1. 简单的GIT命令"></a>1. 简单的GIT命令</h4><p>简单的 git 命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init &#x2F;&#x2F;初始化一个代码库  </span><br><span class="line">git add &#x2F;&#x2F;把工作区的修改，提交到暂存区  </span><br><span class="line">git commit &#x2F;&#x2F;把暂存区的修改，保存至本地库  </span><br><span class="line">git push &#x2F;&#x2F;把本地库的记录，推送至远程库</span><br></pre></td></tr></table></figure>
<h4 id="2-版本管理"><a href="#2-版本管理" class="headerlink" title="2. 版本管理"></a>2. 版本管理</h4><h5 id="2-1-工作区与暂存区"><a href="#2-1-工作区与暂存区" class="headerlink" title="2.1. 工作区与暂存区"></a>2.1. 工作区与暂存区</h5><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>
<p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>
<p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;**understand** how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="https://static.liaoxuefeng.com/files/attachments/919020100829536/0" alt="img"></p>
<h5 id="2-2-版本回退"><a href="#2-2-版本回退" class="headerlink" title="2.2. 版本回退"></a>2.2. 版本回退</h5><p>现在总结一下：</p>
<p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p>
<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<h5 id="2-3-撤销修改"><a href="#2-3-撤销修改" class="headerlink" title="2.3. 撤销修改"></a>2.3. 撤销修改</h5><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<h5 id="2-4-删除文件"><a href="#2-4-删除文件" class="headerlink" title="2.4. 删除文件"></a>2.4. 删除文件</h5><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<h4 id="3-远程仓库"><a href="#3-远程仓库" class="headerlink" title="3. 远程仓库"></a>3. 远程仓库</h4><p>我们可以通过类似Github的代码托管网站使用git来管理我们的代码</p>
<h5 id="3-1-添加远程库"><a href="#3-1-添加远程库" class="headerlink" title="3.1. 添加远程库"></a>3.1. 添加远程库</h5><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<h5 id="3-2-从远程库克隆"><a href="#3-2-从远程库克隆" class="headerlink" title="3.2. 从远程库克隆"></a>3.2. 从远程库克隆</h5><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p>
<h4 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4. 分支管理"></a>4. 分支管理</h4><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<p><img src="https://static.liaoxuefeng.com/files/attachments/919021987875136/0" alt="img"></p>
<h5 id="4-1-创建与合并分支"><a href="#4-1-创建与合并分支" class="headerlink" title="4.1. 创建与合并分支"></a>4.1. 创建与合并分支</h5><p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h5 id="4-2-解决冲突"><a href="#4-2-解决冲突" class="headerlink" title="4.2. 解决冲突"></a>4.2. 解决冲突</h5><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h5 id="4-3-分支策略"><a href="#4-3-分支策略" class="headerlink" title="4.3. 分支策略"></a>4.3. 分支策略</h5><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>
<p>修改readme.txt文件，并提交一个新的commit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>
<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|&#x2F;  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<h5 id="4-4-Bug分支"><a href="#4-4-Bug分支" class="headerlink" title="4.4. Bug分支"></a>4.4. Bug分支</h5><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h5 id="4-5-Feature分支"><a href="#4-5-Feature分支" class="headerlink" title="4.5. Feature分支"></a>4.5. Feature分支</h5><p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h5 id="4-6-多人协作"><a href="#4-6-多人协作" class="headerlink" title="4.6. 多人协作"></a>4.6. 多人协作</h5><p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h4 id="5-标签管理"><a href="#5-标签管理" class="headerlink" title="5. 标签管理"></a>5. 标签管理</h4><h5 id="5-1-创建标签"><a href="#5-1-创建标签" class="headerlink" title="5.1. 创建标签"></a>5.1. 创建标签</h5><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</p>
<p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p>
<p>命令<code>git tag</code>可以查看所有标签。</p>
<h5 id="5-2-操作标签"><a href="#5-2-操作标签" class="headerlink" title="5.2. 操作标签"></a>5.2. 操作标签</h5><p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p>
<p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>
<p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>
<p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>
<h4 id="6-使用GitHub"><a href="#6-使用GitHub" class="headerlink" title="6. 使用GitHub"></a>6. 使用GitHub</h4><p>在GitHub上，可以任意Fork开源仓库；</p>
<p>自己拥有Fork后的仓库的读写权限；</p>
<p>可以推送pull request给官方仓库来贡献代码。</p>
<h4 id="7-自定义Git"><a href="#7-自定义Git" class="headerlink" title="7. 自定义Git"></a>7. 自定义Git</h4><h5 id="7-1-忽略特殊文件"><a href="#7-1-忽略特殊文件" class="headerlink" title="7.1. 忽略特殊文件"></a>7.1. 忽略特殊文件</h5><p>忽略某些文件时，需要编写<code>.gitignore</code>；</p>
<p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>

        
      </div>
    </div>

    

  </div>

  <footer class="article-footer">
    <div class="article-more-info">
      <div class="article-date">
  <time datetime="2021-01-02T12:33:17.000Z" itemprop="datePublished">2021-01-02</time>
</div>
      
        <div class="article-category">
          <a class="article-category-link" href="/categories/git/">git</a>
        </div>
      
      
        <div class="article-tag">
          <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/abc/" rel="tag">abc</a></li></ul>
        </div>
      
    </div>
  </footer>

</article>

    
  

  
</div>

                </section>
            </section>

             
            <aside class="sidebar">
            
                


<div class="widget" id="widget">
    
      
    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/papers/">papers</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GAME-design/" rel="tag">GAME design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/abc/" rel="tag">abc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fpga-accelator/" rel="tag">fpga accelator</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2021/01/03/GEAch3/">GEAch3</a>
          </li>
        
          <li>
            <a href="/2021/01/02/diannao/">DIANNAO论文导读</a>
          </li>
        
          <li>
            <a href="/2021/01/02/git/">GIT 入门</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            存在主义是一种人道主义 &copy; 2021<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>




<script src="/dist/build.js?1.13.0.js"></script>


<script src="/dist/custom.js?1.13.0.js"></script>









</body>

</html>